/**
 * package SCSA.ImageJ This is a modified Colour_Deconvolution plugin provided
 * by Gabriel Landini Plugin modified by Dmitry Turbin on July 27, 2011
 */
package ca.ubc.gpec.ia.analyzer.deconvolution;

import ca.ubc.gpec.ia.analyzer.settings.StainAnalyzerSettings;
import ij.*;
import ij.gui.*;
import ij.plugin.*;
import ij.process.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

public class ColourDeconvolution implements PlugIn {

// G.Landini at bham ac uk
// 30/Mar/2004 released
// 03/Apr/2004 resolved ROI exiting
// 07/Apr/2004 added Methyl Green DAB vectors
// 08/Jul/2004 shortened the code
// 01/Aug/2005 added fast red/blue/DAB vectors
// 02/Nov/2005 changed code to work with image stacks (DLC - dchao at fhcrc org)
// 02/Nov/2005 changed field names so user-defined colours can be set within 
//             macros (DLC - dchao at fhcrc org)
// 04/Feb/2007 1.3 disable popup menu when right clicking
// 23/May/2009 added Feulgen-light green vectors
//14/Apr/2010 v 1.4 added Giemsa vector (Methylene blue & eosin) 
//           the images are now names "title"-(Colour_1) etc so there are not clash of names when using [ ]
//           the log window now prints the java code of the translation matrix to include new vectors in the plugin.
//           added "Hide legend" option
//22/Jun/2010 v 1.5 added Masson Trichrome vector (Methyl blue & Ponceau Fuchsin only (this does not have Iron Haematoxylin vector!)
//           fixed bug: check for 0 components before hiding legend (otherwise there was no image shown if legent hidden) 
//
//24/Aug/2011 v 1.6 - moved the constants (e.g. channel matrices values) to ColourDeconvolutionConstants.java
//                  - added private variable settings (StainAnalyzerSettings) ... to get user defined channel matrices values	
// This plugin implements stain separation using the colour deconvolution
// method described in:
//
//     Ruifrok AC, Johnston DA. Quantification of histochemical
//     staining by color deconvolution. Analytical & Quantitative
//     Cytology & Histology 2001; 23: 291-299.
//
// The code is based on "Color separation-30", a macro for NIH Image kindly provided
// by A.C. Ruifrok. Thanks Arnout!
//
// The plugin assumes images generated by color subtraction (i.e. light-absorbing dyes
// such as those used in bright field histology or ink on printed paper) but the dyes
// should not be neutral grey.
//
// I strongly suggest to read the paper reference above to understand how to determine
// new vectors and how the whole procedure works.
//
// The plugin works correctly when the background is neutral (white to light grey), 
// so background subtraction and colour correction must be applied to the images before 
// processing.
//
// The plugin provides a number of "built in" stain vectors some of which were determined
// experimentally in our lab (marked GL), but you may have to determine your own vectors to
// provide a more accurate stain separation, depending on the stains and methods you use.
// Ideally, vector determination should be done on slides stained with only one colour
// at a time (using the "From ROI" interactive option).
//
// The plugin takes an RGB image and returns three 8-bit images. If the specimen is
// stained with a 2 colour scheme (such as H & E) the 3rd image represents the
// complimentary of the first two colours (i.e. green).
//
// Please be *very* careful about how to interpret the results of colour deconvolution
// when analysing histological images.
// Most staining methods are not stochiometric and so optical density of the chromogen
// may not correlate well with the *quantity* of the reactants.
// This means that optical density of the colour may not be a good indicator of
// the amount of material stained.
//
// Read the paper!
//
    private Hashtable images = new Hashtable(); /// GPEC mod - added hashtable to hold the result images
    private ImagePlus originalImp;              /// GPEC mod - the original image
    private ColourDeconvolutionConstants constants = ColourDeconvolutionConstants.getInstance();
    private StainAnalyzerSettings settings;

    /**
     * populate settings
     *
     * @param settings
     */
    public void setStainAnalyzerSettings(StainAnalyzerSettings settings) {
        this.settings = settings;
    }

    public void run(String arg) {
        System.out.println("running ColourDeconvolution.run() ...");
        /*
         * ImagePlus imp = WindowManager.getCurrentImage(); if (imp==null){
         * IJ.error("No image!"); return; }
         */
        /// GPEC mod
        ImagePlus imp = null;
        if (originalImp != null) {
            imp = originalImp;
        } else {
            imp = WindowManager.getCurrentImage();
        }

        if (imp.getBitDepth() != 24) {
            IJ.error("RGB image needed.");
            System.err.println("RGB image needed.");
            return;
        }
        ImageStack stack = imp.getStack();
        int width = stack.getWidth();
        int height = stack.getHeight();
        String title = imp.getTitle();

//		GenericDialog gd = new GenericDialog("Colour Deconvolution 1.5", IJ.getInstance());
        //gd.addMessage("Select subtractive colour model");
        //String [] stains = {"H DAB", "H&E", "H&E 2", "Feulgen Light Green", "Giemsa", "FastRed FastBlue DAB", "Methyl Green DAB", "H&E DAB", "H AEC","Azan-Mallory","Masson Trichrome","Alcian blue & H","H PAS","RGB","CMY", "From ROI", "User values"};
//      String [] stain={"From ROI", "H&E", "H&E 2","H DAB", "Feulgen Light Green", "Giemsa", "FastRed FastBlue DAB", "Methyl Green DAB", "H&E DAB", "H AEC","Azan-Mallory","Masson Trichrome","Alcian blue & H","H PAS","RGB","CMY", "User values"};
//		gd.addChoice("Vectors", stain, stain[0]);
//		gd.addCheckbox("Show matrices",false);
//		gd.addCheckbox("Hide legend",false);

        //gd.addCheckbox("Linear image",false);

//		gd.showDialog();
//		if (gd.wasCanceled())
//			return;
//		String myStain = gd.getNextChoice();
//		boolean doIshow = gd.getNextBoolean();
//		boolean hideLegend = gd.getNextBoolean();

        String myStain = arg; // I believe it was added by Andy Chan
        boolean doIshow = false; // I believe it was added by Andy Chan

        double leng, A, V, C, log255 = Math.log(255.0);
        int i, j;
        double[] MODx = new double[3];
        double[] MODy = new double[3];
        double[] MODz = new double[3];
        double[] cosx = new double[3];
        double[] cosy = new double[3];
        double[] cosz = new double[3];
        double[] len = new double[3];
        double[] q = new double[9];
        byte[] rLUT = new byte[256];
        byte[] gLUT = new byte[256];
        byte[] bLUT = new byte[256];

// stains are defined after this line

        System.out.println("stain option ..."+myStain);
        
        if (myStain.equals(constants.STAIN_OPTION_FROM_ROI)) {
       
            IJ.runMacro("setOption('DisablePopupMenu', true)");
            // imp.getCanvas().disablePopupMenu(true);
            double[] rgbOD = new double[3];
            for (i = 0; i < 3; i++) {
                getmeanRGBODfromROI(i, rgbOD, imp);
                MODx[i] = rgbOD[0];
                MODy[i] = rgbOD[1];
                MODz[i] = rgbOD[2];
            }

            IJ.runMacro("setOption('DisablePopupMenu', false)");
            // imp.getCanvas().disablePopupMenu(false);


        } else {
            // the following line gets user-defined channel matrix as well.
            double[][] channelMatrix = constants.getChannelMatrix(myStain, settings);

            MODx[0] = channelMatrix[0][0];
            MODy[0] = channelMatrix[0][1];
            MODz[0] = channelMatrix[0][2];

            MODx[1] = channelMatrix[1][0];
            MODy[1] = channelMatrix[1][1];
            MODz[1] = channelMatrix[1][2];

            MODx[2] = channelMatrix[2][0];
            MODy[2] = channelMatrix[2][1];
            MODz[2] = channelMatrix[2][2];

        }

        // start
        for (i = 0; i < 3; i++) {
            //normalise vector length
            cosx[i] = cosy[i] = cosz[i] = 0.0;
            len[i] = Math.sqrt(MODx[i] * MODx[i] + MODy[i] * MODy[i] + MODz[i] * MODz[i]);
            if (len[i] != 0.0) {
                cosx[i] = MODx[i] / len[i];
                cosy[i] = MODy[i] / len[i];
                cosz[i] = MODz[i] / len[i];
            }
        }


        // translation matrix
        if (cosx[1] == 0.0) { //2nd colour is unspecified
            if (cosy[1] == 0.0) {
                if (cosz[1] == 0.0) {
                    cosx[1] = cosz[0];
                    cosy[1] = cosx[0];
                    cosz[1] = cosy[0];
                }
            }
        }

        if (cosx[2] == 0.0) { // 3rd colour is unspecified
            if (cosy[2] == 0.0) {
                if (cosz[2] == 0.0) {
                    if ((cosx[0] * cosx[0] + cosx[1] * cosx[1]) > 1) {
                        if (doIshow) {
                            IJ.log("Colour_3 has a negative R component.");
                        }
                        cosx[2] = 0.0;
                    } else {
                        cosx[2] = Math.sqrt(1.0 - (cosx[0] * cosx[0]) - (cosx[1] * cosx[1]));
                    }

                    if ((cosy[0] * cosy[0] + cosy[1] * cosy[1]) > 1) {
                        if (doIshow) {
                            IJ.log("Colour_3 has a negative G component.");
                        }
                        cosy[2] = 0.0;
                    } else {
                        cosy[2] = Math.sqrt(1.0 - (cosy[0] * cosy[0]) - (cosy[1] * cosy[1]));
                    }

                    if ((cosz[0] * cosz[0] + cosz[1] * cosz[1]) > 1) {
                        if (doIshow) {
                            IJ.log("Colour_3 has a negative B component.");
                        }
                        cosz[2] = 0.0;
                    } else {
                        cosz[2] = Math.sqrt(1.0 - (cosz[0] * cosz[0]) - (cosz[1] * cosz[1]));
                    }
                }
            }
        }

        leng = Math.sqrt(cosx[2] * cosx[2] + cosy[2] * cosy[2] + cosz[2] * cosz[2]);

        cosx[2] = cosx[2] / leng;
        cosy[2] = cosy[2] / leng;
        cosz[2] = cosz[2] / leng;

        for (i = 0; i < 3; i++) {
            if (cosx[i] == 0.0) {
                cosx[i] = 0.001;
            }
            if (cosy[i] == 0.0) {
                cosy[i] = 0.001;
            }
            if (cosz[i] == 0.0) {
                cosz[i] = 0.001;
            }
        }

        /*
         * by Dmitry - beginning of comment if (!hideLegend) { ImagePlus imp0 =
         * NewImage.createRGBImage("Colour Deconvolution", 350, 65, 1, 0);
         * ImageProcessor ip0 = imp0.getProcessor(); ip0.setFont(new
         * Font("Monospaced", Font.BOLD, 11)); ip0.setAntialiasedText(true);
         * ip0.setColor(Color.black); ip0.moveTo(10,15); ip0.drawString("Colour
         * deconvolution: "+myStain); ip0.setFont(new Font("Monospaced",
         * Font.PLAIN, 10));
         *
         * for (i=0; i<3; i++){ ip0.setRoi(10,18+ i*15, 14, 14); ip0.setColor(
         * (((255 -(int)(255.0* cosx[i])) & 0xff)<<16)+ (((255 -(int)(255.0*
         * cosy[i])) & 0xff)<<8 )+ (((255 -(int)(255.0* cosz[i])) & 0xff) ));
         * ip0.fill(); ip0.setFont(new Font("Monospaced", Font.PLAIN, 10));
         * ip0.setAntialiasedText(true); ip0.setColor(Color.black);
         * ip0.moveTo(27,32+ i*15); ip0.drawString("Colour_"+(i+1)+"
         * R:"+(float)cosx[i]+", G:"+(float)cosy[i]+", B:"+(float)cosz[i] ); }
         * imp0.show(); imp0.updateAndDraw(); }
         */ // by Dmitry - end of comment

// the next section was commented out by Gabriel Landini, present in the GPEC old plugin		
/*
         * if (myStain.equals("From ROI")){
         * IJ.showMessage("Vectors","Colour[1]:\n"+ " R: "+(float) cosx[0]
         * +"\n"+ " G: "+(float) cosy[0] +"\n"+ " B: "+(float) cosz[0] +"\n \n"+
         * "Colour[2]:\n"+ " R: "+ (float) cosx[1] +"\n"+ " G: "+ (float)
         * cosy[1] +"\n"+ " B: "+ (float) cosz[1] +"\n \n"+ "Colour[3]:\n"+ " R:
         * "+ (float) cosx[2] +"\n"+ " G: "+ (float) cosy[2] +"\n"+ " B: "+
         * (float) cosz[2]); }
         */
// end of the commented out section by Landini

        if (doIshow) {
            IJ.log(myStain + " Vector Matrix ---");
            for (i = 0; i < 3; i++) {
                IJ.log("Colour[" + (i + 1) + "]:\n"
                        + "  R" + (i + 1) + ": " + (float) MODx[i] + "\n"
                        + "  G" + (i + 1) + ": " + (float) MODy[i] + "\n"
                        + "  B" + (i + 1) + ": " + (float) MODz[i] + "\n \n");
            }

            /*
             * IJ.log( myStain +" Translation Matrix ---"); for (i=0; i<3; i++){
             * IJ.log("Colour["+(i+1)+"]:\n"+ " R"+(i+1)+": "+ (float) cosx[i]
             * +"\n"+ " G"+(i+1)+": "+ (float) cosy[i] +"\n"+ " B"+(i+1)+": "+
             * (float) cosz[i] +"\n \n"); }
             */
            IJ.log(myStain + " Java code ---");
            IJ.log("\t\tif (myStain.equals(\"New_Stain\")){");
            IJ.log("\t\t// This is the New_Stain");
            for (i = 0; i < 3; i++) {
                IJ.log("\t\t\tMODx[" + i + "]=" + (float) cosx[i] + ";\n"
                        + "\t\t\tMODy[" + i + "]=" + (float) cosy[i] + ";\n"
                        + "\t\t\tMODz[" + i + "]=" + (float) cosz[i] + ";\n\n");
            }
            IJ.log("}");
        }

        //matrix inversion
        A = cosy[1] - cosx[1] * cosy[0] / cosx[0];
        V = cosz[1] - cosx[1] * cosz[0] / cosx[0];
        C = cosz[2] - cosy[2] * V / A + cosx[2] * (V / A * cosy[0] / cosx[0] - cosz[0] / cosx[0]);
        q[2] = (-cosx[2] / cosx[0] - cosx[2] / A * cosx[1] / cosx[0] * cosy[0] / cosx[0] + cosy[2] / A * cosx[1] / cosx[0]) / C;
        q[1] = -q[2] * V / A - cosx[1] / (cosx[0] * A);
        q[0] = 1.0 / cosx[0] - q[1] * cosy[0] / cosx[0] - q[2] * cosz[0] / cosx[0];
        q[5] = (-cosy[2] / A + cosx[2] / A * cosy[0] / cosx[0]) / C;
        q[4] = -q[5] * V / A + 1.0 / A;
        q[3] = -q[4] * cosy[0] / cosx[0] - q[5] * cosz[0] / cosx[0];
        q[8] = 1.0 / C;
        q[7] = -q[8] * V / A;
        q[6] = -q[7] * cosy[0] / cosx[0] - q[8] * cosz[0] / cosx[0];

        // initialize 3 output colour stacks
        ImageStack[] outputstack = new ImageStack[3];
        for (i = 0; i < 3; i++) {
            for (j = 0; j < 256; j++) { //LUT[1]
                //if (cosx[i] < 0)
                //	rLUT[255-j]=(byte)(255.0 + (double)j * cosx[i]);
                //else
                rLUT[255 - j] = (byte) (255.0 - (double) j * cosx[i]);

                //if (cosy[i] < 0)
                //	gLUT[255-j]=(byte)(255.0 + (double)j * cosy[i]);
                //else
                gLUT[255 - j] = (byte) (255.0 - (double) j * cosy[i]);

                //if (cosz[i] < 0)
                //	bLUT[255-j]=(byte)(255.0 + (double)j * cosz[i]);
                ///else
                bLUT[255 - j] = (byte) (255.0 - (double) j * cosz[i]);
            }
            IndexColorModel cm = new IndexColorModel(8, 256, rLUT, gLUT, bLUT);
            outputstack[i] = new ImageStack(width, height, cm);
        }

        // translate ------------------
        int imagesize = width * height;
        for (int imagenum = 1; imagenum <= stack.getSize(); imagenum++) {
            int[] pixels = (int[]) stack.getPixels(imagenum);
            String label = stack.getSliceLabel(imagenum);
            byte[][] newpixels = new byte[3][];
            newpixels[0] = new byte[imagesize];
            newpixels[1] = new byte[imagesize];
            newpixels[2] = new byte[imagesize];

            for (j = 0; j < imagesize; j++) {
                // log transform the RGB data
                int R = (pixels[j] & 0xff0000) >> 16;
                int G = (pixels[j] & 0x00ff00) >> 8;
                int B = (pixels[j] & 0x0000ff);
                double Rlog = -((255.0 * Math.log(((double) R + 1) / 255.0)) / log255);
                double Glog = -((255.0 * Math.log(((double) G + 1) / 255.0)) / log255);
                double Blog = -((255.0 * Math.log(((double) B + 1) / 255.0)) / log255);
                for (i = 0; i < 3; i++) {
                    // rescale to match original paper values
                    double Rscaled = Rlog * q[i * 3];
                    double Gscaled = Glog * q[i * 3 + 1];
                    double Bscaled = Blog * q[i * 3 + 2];
                    double output = Math.exp(-((Rscaled + Gscaled + Bscaled) - 255.0) * log255 / 255.0);
                    if (output > 255) {
                        output = 255;
                    }
                    newpixels[i][j] = (byte) (0xff & (int) (Math.floor(output + .5)));
                }
            }
            // add new values to output images
            outputstack[0].addSlice(label, newpixels[0]);
            outputstack[1].addSlice(label, newpixels[1]);
            outputstack[2].addSlice(label, newpixels[2]);
        }
        /*
         * that was the original Gabriel Landini's block - commented out by
         * Dmitry Turbin new
         * ImagePlus(title+"-(Colour_1)",outputstack[0]).show(); new
         * ImagePlus(title+"-(Colour_2)",outputstack[1]).show(); new
         * ImagePlus(title+"-(Colour_3)",outputstack[2]).show();
         */

        ImagePlus imp1 = new ImagePlus("Colour [1]", outputstack[0]); // mod by Dmitry
        images.put("Colour [1]", imp1); // mod by Dmitry
        ImagePlus imp2 = new ImagePlus("Colour [2]", outputstack[1]); // mod by Dmitry
        images.put("Colour [2]", imp2); // mod by Dmitry
        ImagePlus imp3 = new ImagePlus("Colour [3]", outputstack[2]); // mod by Dmitry; we don't use this image
        images.put("Colour [3]", imp3); // mod by Dmitry; we don't use this image
    }

    void getmeanRGBODfromROI(int i, double[] rgbOD, ImagePlus imp) {
        //get a ROI and its mean optical density. GL
        int[] xyzf = new int[4]; //[0]=x, [1]=y, [2]=z, [3]=flags
        int x1, y1, x2, y2, h = 0, w = 0, px = 0, py = 0, x, y, p;
        double log255 = Math.log(255.0);
        ImageProcessor ip = imp.getProcessor();
        int mw = ip.getWidth() - 1;
        int mh = ip.getHeight() - 1;

        IJ.showMessage("Select ROI for Colour_" + (i + 1) + ".\n \n(Right-click to end)");
        getCursorLoc(xyzf, imp);
        while ((xyzf[3] & 4) != 0) {  //trap until right released
            getCursorLoc(xyzf, imp);
            IJ.wait(20);
        }

        while (((xyzf[3] & 16) == 0) && ((xyzf[3] & 4) == 0)) { //trap until one is pressed
            getCursorLoc(xyzf, imp);
            IJ.wait(20);
        }

        rgbOD[0] = 0;
        rgbOD[1] = 0;
        rgbOD[2] = 0;

        if ((xyzf[3] & 4) == 0) {// right was not pressed, but left (ROI) was
            x1 = xyzf[0];
            y1 = xyzf[1];
            //IJ.write("first point x:" + x1 + "  y:" + y1);
            x2 = x1;
            y2 = y1;
            while ((xyzf[3] & 4) == 0) {//until right pressed
                getCursorLoc(xyzf, imp);
                if (xyzf[0] != x2 || xyzf[1] != y2) {
                    if (xyzf[0] < 0) {
                        xyzf[0] = 0;
                    }
                    if (xyzf[1] < 0) {
                        xyzf[1] = 0;
                    }
                    if (xyzf[0] > mw) {
                        xyzf[0] = mw;
                    }
                    if (xyzf[1] > mh) {
                        xyzf[1] = mh;
                    }
                    x2 = xyzf[0];
                    y2 = xyzf[1];
                    w = x2 - x1 + 1;
                    h = y2 - y1 + 1;
                    if (x2 < x1) {
                        px = x2;
                        w = (x1 - x2) + 1;
                    } else {
                        px = x1;
                    }
                    if (y2 < y1) {
                        py = y2;
                        h = (y1 - y2) + 1;
                    } else {
                        py = y1;
                    }
                    IJ.makeRectangle(px, py, w, h);
                    //IJ.write("Box x:" + x2 +"  y:" + y2+" w:"+w+" h:"+h);
                }
                IJ.wait(20);
            }
            while ((xyzf[3] & 16) != 0) {  //trap until left released
                getCursorLoc(xyzf, imp);
                IJ.wait(20);
            }

            for (x = px; x < (px + w); x++) {
                for (y = py; y < (py + h); y++) {
                    p = ip.getPixel(x, y);
                    // rescale to match original paper values
                    rgbOD[0] = rgbOD[0] + (-((255.0 * Math.log(((double) ((p & 0xff0000) >> 16) + 1) / 255.0)) / log255));
                    rgbOD[1] = rgbOD[1] + (-((255.0 * Math.log(((double) ((p & 0x00ff00) >> 8) + 1) / 255.0)) / log255));
                    rgbOD[2] = rgbOD[2] + (-((255.0 * Math.log(((double) ((p & 0x0000ff)) + 1) / 255.0)) / log255));
                }
            }
            rgbOD[0] = rgbOD[0] / (w * h);
            rgbOD[1] = rgbOD[1] / (w * h);
            rgbOD[2] = rgbOD[2] / (w * h);
        }
        IJ.run("Select None");
    }

    void getCursorLoc(int[] xyzf, ImagePlus imp) {
        ImageWindow win = imp.getWindow();
        ImageCanvas ic = win.getCanvas();
        Point p = ic.getCursorLoc();
        xyzf[0] = p.x;
        xyzf[1] = p.y;
        xyzf[2] = imp.getCurrentSlice() - 1;
        xyzf[3] = ic.getModifiers();
    }

    /// GPEC mod - added method to allow retrieval of images
    public ImagePlus getImage(String title) {
        ImagePlus imp = null;
        if (images.containsKey(title)) {
            imp = (ImagePlus) images.get(title);
        }
        return imp;
    }

    /// GPEC mod - sets the image to be colour deconvoluted
    public void setImage(ImagePlus imp) {
        originalImp = imp;
    }
}
