/*
 * Aperio annotation XML file ... Region element
 */
package ca.ubc.gpec.ia.analyzer.reader.aperioAnnotation.model;

import ca.ubc.gpec.ia.analyzer.model.guidedManualScorer.NucleiSelections;
import ca.ubc.gpec.ia.analyzer.reader.aperioAnnotation.exception.RegionNotSupportedException;
import ca.ubc.gpec.ia.analyzer.reader.aperioAnnotation.exception.RegionNotPreprocessedException;
import ij.ImagePlus;
import ij.gui.OvalRoi;
import ij.gui.PolygonRoi;
import ij.gui.Roi;
import ij.process.FloatPolygon;
import java.awt.Color;
import java.awt.Rectangle;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Iterator;
import java.util.Random;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;
import loci.formats.FormatException;
import loci.formats.IFormatReader;
import loci.formats.gui.BufferedImageReader;

/**
 *
 * @author samuelc
 */
@XmlRootElement(name = "Region")
public class Region implements Comparable {

    // aperio region type id ... determined empirically by looking into the xml file
    // not sure if/when aperio will change them!!!
    public static final int REGION_TYPE_FREE_HAND = 0;
    public static final int REGION_TYPE_RECTANGLE = 1;
    public static final int REGION_TYPE_ELLIPSE = 2;
    private int id;
    private int type;
    private String text;
    private Attributes attributes;
    private Vertices vertices;
    // below are all NON-APERIO fields!!!
    private int randomRotationInDegree; // rotation in radian
    /// non-xml fields
    private int enclosingRectangleWidth; // generated in preprocess()
    private int enclosingRectangleHeight; // generated in preprocess()
    private int enclosingRectangleX; // generated in preprocess()
    private int enclosingRectangleY; // generated in preprocess()
    float[] xArr; // x coordinates of ROI; generated in preprocess()
    float[] yArr; // y coordinates of ROI; generated in preprocess()
    boolean preprocessed; // indicates if preprocessing has been done e.g. calculate enclose rectangle coordinate; generated in preprocess()      
    NucleiSelections nucleiSelections; // nuclei selection for scoring
    private double area; // area of region

    /**
     * constructor
     */
    public Region() {
        preprocessed = false;
    }

    /**
     * return a deep copy of this
     *
     * @return
     */
    @Override
    public Region clone() {
        Region clone = new Region();
        clone.setId(this.id);
        clone.setType(this.type);
        clone.setText(this.text);
        clone.setAttributes(this.attributes == null ? null : this.attributes.clone());
        clone.setVertices(this.vertices == null ? null : this.vertices.clone());
        // allow the clone to do the preprocess itself ... therefore, no need
        // to set the fields that are generated by preprocess()
        clone.setNucleiSelections(this.nucleiSelections == null ? null : this.nucleiSelections.clone());
        return clone;
    }

    @XmlAttribute(name = "Id")
    public void setId(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    @XmlAttribute(name = "Type")
    public void setType(int type) {
        this.type = type;
    }

    public int getType() {
        return type;
    }

    @XmlAttribute(name = "Text")
    public void setText(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }

    @XmlAttribute(name = "GPEC_randomRotationInDegree")
    public void setRandomRotationInDegree(int randomRotationInDegree) {
        this.randomRotationInDegree = randomRotationInDegree;
    }

    public int getRandomRotationInDegree() {
        return randomRotationInDegree;
    }

    @XmlElement(name = "Attributes")
    public void setAttributes(Attributes attributes) {
        this.attributes = attributes;
    }

    public Attributes getAttributes() {
        return attributes;
    }

    @XmlElement(name = "NucleiSelections")
    public void setNucleiSelections(NucleiSelections nucleiSelections) {
        this.nucleiSelections = nucleiSelections;
    }

    public NucleiSelections getNucleiSelections() {
        return nucleiSelections;
    }

    @XmlElement(name = "Vertices")
    public void setVertices(Vertices vertices) {
        this.vertices = vertices;
    }

    /**
     * get the list of vertices, ordered by the order in which they are read in
     *
     * @return
     */
    public Vertices getVertices() {
        return vertices;
    }

    /**
     * get first vertex
     *
     * @return
     */
    public Vertex getFirstVertex() {
        return vertices.getFirstVertex();
    }

    /**
     * get last vertex
     *
     * @return
     */
    public Vertex getLastVertex() {
        return vertices.getLastVertex();
    }

    /**
     * check to see if it is preprocessed
     *
     * @return
     */
    public boolean isPreprocessed() {
        return preprocessed;
    }

    public int getEnclosingRectangleX() throws RegionNotPreprocessedException {
        if (!preprocessed) {
            throw new RegionNotPreprocessedException("");
        }
        return enclosingRectangleX;
    }

    public int getEnclosingRectangleY() throws RegionNotPreprocessedException {
        if (!preprocessed) {
            throw new RegionNotPreprocessedException("");
        }
        return enclosingRectangleY;
    }

    public int getEnclosingRectangleWidth() throws RegionNotPreprocessedException {
        if (!preprocessed) {
            throw new RegionNotPreprocessedException("");
        }
        return enclosingRectangleWidth;
    }

    public int getEnclosingRectangleHeight() throws RegionNotPreprocessedException {
        if (!preprocessed) {
            throw new RegionNotPreprocessedException("");
        }
        return enclosingRectangleHeight;
    }

    /**
     * for Comparable interface
     *
     * @param other
     * @return
     */
    @Override
    public int compareTo(Object other) {
        Region otherRegion = (Region) other;
        return this.id - otherRegion.id;
    }

    /**
     * check to see if region type is free hand
     *
     * @return
     */
    public boolean isTypeFreeHand() {
        return type == Region.REGION_TYPE_FREE_HAND;
    }

    /**
     * check to see if region type is rectangle
     *
     * @return
     */
    public boolean isTypeRectangle() {
        return type == Region.REGION_TYPE_RECTANGLE;
    }

    /**
     * check to see if region type is ellipse
     *
     * @return
     */
    public boolean isTypeEllipse() {
        return type == Region.REGION_TYPE_ELLIPSE;
    }

    /**
     * do preprocessing ... must be called first
     *
     * @param imageWidth
     * @param imageHeight
     */
    public void preprocess(float imageWidth, float imageHeight) throws RegionNotSupportedException {
        if (isTypeFreeHand() || isTypeRectangle() || isTypeEllipse()) {
            // 1. find smallest rectangle enclosing the ROI
            // 2. get x/y coordinates of all vertices
            float minX = Float.MAX_VALUE;
            float minY = Float.MAX_VALUE;
            float maxX = Float.MIN_VALUE;
            float maxY = Float.MIN_VALUE;
            int numVertices = vertices.vertices.size();
            xArr = new float[numVertices];
            yArr = new float[numVertices];
            int i = 0;
            Iterator<Vertex> vertexItr = vertices.vertices.iterator();
            while (vertexItr.hasNext()) {
                Vertex v = vertexItr.next();
                float x = Math.min(imageWidth, v.getX());
                float y = Math.min(imageHeight, v.getY());
                minX = minX < x ? minX : x;
                minY = minY < y ? minY : y;
                maxX = maxX > x ? maxX : x;
                maxY = maxY > y ? maxY : y;
                xArr[i] = x;
                yArr[i] = y;
                i++;
            }
            enclosingRectangleX = (int) Math.floor(minX);
            enclosingRectangleY = (int) Math.floor(minY);
            enclosingRectangleWidth = (int) Math.floor(maxX - minX);
            enclosingRectangleHeight = (int) Math.floor(maxY - minY);

            // xArr and yArr is in the coordinate system of ROI
            // i.e. min x/y should be 0,0
            for (int j = 0; j < numVertices; j++) {
                xArr[j] = xArr[j] - enclosingRectangleX;
                yArr[j] = yArr[j] - enclosingRectangleY;
            }
        } else {
            throw new RegionNotSupportedException("Region type (" + type + ") not supported.");
        }

        preprocessed = true; // indicate that preprocess is done
        try {
            // calculate area ...
            area = calculateArea();
        } catch (RegionNotPreprocessedException ex) {
            // not possible!!! since just finished preprocess!!!
        }
    }

    /**
     * get ROI
     *
     * @return
     * @throws RegionNotSupportedException
     * @throws RegionNotPreprocessedException
     */
    public Roi getRoi() throws RegionNotSupportedException, RegionNotPreprocessedException {
        return getRoi(1, 1, false);
    }

    /**
     * get pre-calculated (calculated during preprocess) area
     *
     * @return
     * @throws RegionNotPreprocessedException
     */
    public double getArea() throws RegionNotPreprocessedException {
        if (!preprocessed) {
            throw new RegionNotPreprocessedException("");
        }
        return area;
    }

    /**
     * get size of ROI
     *
     * @return
     * @throws RegionNotSupportedException
     * @throws RegionNotPreprocessedException
     */
    public double calculateArea() throws RegionNotSupportedException, RegionNotPreprocessedException {
        Roi roi = getRoi();
        double area = enclosingRectangleWidth * enclosingRectangleHeight;

        if (isTypeEllipse()) {
            // http://en.wikipedia.org/wiki/Ellipse#Area
            area = enclosingRectangleWidth * 0.5 * enclosingRectangleHeight * 0.5 * Math.PI;
        } else if (isTypeFreeHand()) {
            // this is an APPROXIMATION ONLY!!!!
            // 1. start with area of enclosing rectangle
            // 2. try random n pixels and tabulate which are inside/outside the area
            // 3. area = percent pixal inside area * area of enclosing rectangle
            Area a = new Area(roi.getPolygon());
            int n = 1000000; // one million test pixels
            Random random = new Random(enclosingRectangleX);
            int count = 0; // kee track of number of pixels INSIDE the roi
            for (int i = 0; i < n; i++) {
                int randomX = random.nextInt(enclosingRectangleWidth);
                int randomY = random.nextInt(enclosingRectangleHeight);
                // note: randomX/Y relative to a
                if (a.contains(randomX, randomY)) { // roi.contains(x,y) ... doesn't seems to work
                    count++;
                }
            }
            area = area * ((double) count / (double) n);
        }
        return area;
    }

    /**
     *
     * @param xScale - scaling factor for x-axis
     * @param yScale - scaling factor for y-axis
     * @offset - if true, offset x/y, otherwise, x/y to 0
     * @return
     * @throws RegionNotSupportedException
     * @throws RegionNotPreprocessedException
     */
    public Roi getRoi(float xScale, float yScale, boolean offset) throws RegionNotSupportedException, RegionNotPreprocessedException {
        if (!preprocessed) {
            throw new RegionNotPreprocessedException("");
        }
        if (isTypeFreeHand() || isTypeRectangle()) {
            float[] xArrScaled = new float[xArr.length];
            float[] yArrScaled = new float[yArr.length];
            for (int i = 0; i < xArr.length; i++) {
                xArrScaled[i] = xScale * (xArr[i] + (offset ? enclosingRectangleX : 0));
                yArrScaled[i] = yScale * (yArr[i] + (offset ? enclosingRectangleY : 0));
                // its impossible for xArr.length != yArr.length
            }
            return new PolygonRoi(new FloatPolygon(xArrScaled, yArrScaled), Roi.FREEROI);
        } else if (isTypeEllipse()) {
            OvalRoi ovalRoi = new OvalRoi(
                    offset ? Math.round(((float) enclosingRectangleX) * xScale) : 0, // always 0 because it is relative to the enclosing rectangle
                    offset ? Math.round(((float) enclosingRectangleY) * yScale) : 0, // always 0 because it is relative to the enclosing rectangle
                    Math.round(((float) enclosingRectangleWidth) * xScale),
                    Math.round(((float) enclosingRectangleHeight) * yScale));
            //System.out.println("OvalRoi: "
            //        + enclosingRectangleX + ", "
            //        + enclosingRectangleY + ", "
            //        + enclosingRectangleWidth + ", "
            //        + enclosingRectangleHeight);
            return ovalRoi;
        }
        throw new RegionNotSupportedException("Region type (" + type + ") not supported.");
    }

    /**
     * check to see if the input region (BOUNDING RECTANGLE) is inside this
     * region
     *
     * @param inputRegion
     * @return
     */
    public boolean containsBoundsOf(Region inputRegion) throws RegionNotSupportedException, RegionNotPreprocessedException {
        Rectangle r = new Rectangle(
                inputRegion.getEnclosingRectangleX() - this.getEnclosingRectangleX(),
                inputRegion.getEnclosingRectangleY() - this.getEnclosingRectangleY(),
                inputRegion.getEnclosingRectangleWidth(),
                inputRegion.getEnclosingRectangleHeight());
        Area a = new Area(this.getRoi().getPolygon());
        return a.contains(r);
    }

    /**
     * check to see if the input region (BOUNDING RECTANGLE) specified by x,y,
     * width, height
     *
     * @param x
     * @param y
     * @param width
     * @param height
     * @return
     * @throws RegionNotSupportedException
     * @throws RegionNotPreprocessedException
     */
    public boolean containsBoundsOf(int x, int y, int width, int height) throws RegionNotSupportedException, RegionNotPreprocessedException {
        Rectangle r = new Rectangle(
                x - this.getEnclosingRectangleX(),
                y - this.getEnclosingRectangleY(),
                width,
                height);
        Area a = new Area(this.getRoi().getPolygon());
        return a.contains(r);
    }

    /**
     * check to see if the input region (BOUNDING RECTANGLE) intersects with the
     * BOUNDING RECTANGLE of this region
     *
     * @param inputRegion
     * @return
     * @throws RegionNotSupportedException
     * @throws RegionNotPreprocessedException
     */
    public boolean intersectsBoundsOf(Region inputRegion) throws RegionNotSupportedException, RegionNotPreprocessedException {
        Rectangle inputR = new Rectangle(
                inputRegion.getEnclosingRectangleX() - this.getEnclosingRectangleX(),
                inputRegion.getEnclosingRectangleY() - this.getEnclosingRectangleY(),
                inputRegion.getEnclosingRectangleWidth(),
                inputRegion.getEnclosingRectangleHeight());
        Area thisA = new Area(this.getRoi().getPolygon());
        return thisA.intersects(inputR);
    }

    /**
     * get ROI as BufferedImage
     *
     * @param ir
     * @return
     * @throws FormatException
     * @throws RegionNotPreprocessedException
     * @throws IOException
     * @throws RegionNotSupportedException
     */
    public BufferedImage getBufferedImage(IFormatReader ir) throws FormatException, RegionNotPreprocessedException, IOException, RegionNotSupportedException {
        BufferedImageReader bir = new BufferedImageReader(ir);
        
        System.out.println("trying to extract image: x/y="+getEnclosingRectangleX()+"/"+getEnclosingRectangleY()+", width/height="+getEnclosingRectangleWidth()+"/"+getEnclosingRectangleHeight());
        
        ImagePlus imp = new ImagePlus(
                "",
                bir.openImage(
                0,
                getEnclosingRectangleX(), // x 
                getEnclosingRectangleY(), // y
                getEnclosingRectangleWidth(), // width
                getEnclosingRectangleHeight() // height
                ));
        //System.out.println("x/y/width/height: " + getEnclosingRectangleX() + "/" + getEnclosingRectangleY() + "/" + getEnclosingRectangleWidth() + "/" + getEnclosingRectangleHeight());

        // try do a ROI on the extract image ...
        Roi roi = getRoi();

        imp.getProcessor().setColor(Color.WHITE);
        imp.getProcessor().fillOutside(roi);

        // rotate image
        imp.getProcessor().rotate(randomRotationInDegree);
        return imp.getBufferedImage();
    }
}
